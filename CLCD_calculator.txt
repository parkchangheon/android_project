#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <wiringPi.h>

#define BTN1 23
#define BTN2 24
#define BTN3 26
#define BTN4 21
#define BTN5 22
#define BTN6 11
#define BTN7 12
#define BTN8 13
#define BTN9 10
#define BTN0 27
#define BTNEQL 14
#define BTNPLS 5
#define BTNMIN 6

#define LCD_D4 2
#define LCD_D5 3
#define LCD_D6 1
#define LCD_D7 4
#define LCD_RS 7
#define LCD_EN 0
void write4bits(unsigned char command)
{
    digitalWrite(LCD_D4, (command & 1));
    command >>= 1;
    digitalWrite(LCD_D5, (command & 1));
    command >>= 1;
    digitalWrite(LCD_D6, (command & 1));
    command >>= 1;
    digitalWrite(LCD_D7, (command & 1));
    digitalWrite(LCD_EN, 1);
    delayMicroseconds(10);
    digitalWrite(LCD_EN, 0);
    delayMicroseconds(10);
}
void sendDataCmd4(unsigned char data)
{
    write4bits(((data >> 4) & 0x0f));
    write4bits((data & 0x0f));
    delayMicroseconds(100);
}

void putCmd4(unsigned char cmd)
{
    digitalWrite(LCD_RS, 0);
    sendDataCmd4(cmd);
}

void putChar(char c) {
    digitalWrite(LCD_RS, 1);
    sendDataCmd4(c);
}
void initialize_textlcd() {
    pinMode(LCD_RS, OUTPUT); pinMode(LCD_EN, OUTPUT);
    pinMode(LCD_D4, OUTPUT); pinMode(LCD_D5, OUTPUT);
    pinMode(LCD_D6, OUTPUT); pinMode(LCD_D7, OUTPUT);
    digitalWrite(LCD_RS, 0); digitalWrite(LCD_EN, 0);
    digitalWrite(LCD_D4, 0); digitalWrite(LCD_D5, 0);
    digitalWrite(LCD_D6, 0);  digitalWrite(LCD_D7, 0);
    delay(35);

    putCmd4(0x28);
    putCmd4(0x28); putCmd4(0x28);
    putCmd4(0x0e);
    delay(2);
    putCmd4(0x01);
    delay(2);
}



int calc(char buf[], int len)
{
    int temp[100] = { 0, }; //임시 피연산자 저장할 배열
    char op[100] = { 0, }; //연산자 저장할 배열
    int top = 0; //피연산자 인덱스
    int optop = 0; //연산자 인덱스
    int num = 0; //정수
    int i = 0;

    for (i = 0; i < len; i++) {
        if ('0' <= buf[i] && buf[i] <= '9') { //연산자 추출
            num *= 10;
            num += buf[i] - '0';
        }
        else if (buf[i] == '-' || buf[i] == '+' || buf[i] == '=')  //피연산자 추출
        {
            temp[top++] = num;
            num = 0;
            op[optop++] = buf[i];
        }
    }
    int res = temp[0];
    for (i = 0; i < optop; i++) { //계산
        if (op[i] == '-')
            res = res - temp[i + 1];
        else if (op[i] == '+')
            res = res + temp[i + 1];
    }
    return res;
}



int main(int argc, char** argv) {
    int a[13] = { BTN0, BTN1, BTN2, BTN3, BTN4, BTN5, BTN6, BTN7,
       BTN8, BTN9, BTNEQL, BTNPLS, BTNMIN };
    char buf[100] = "\0";
    char ovrf[100] = "overflow";
    char invalid[100] = "invalid";
    char oper[100] = "operation";

    int invalid_len = strlen(invalid);
    int oper_len = strlen(oper);
    int ovrf_len = strlen(ovrf);
    int len = strlen(buf);

    int i = 0;
    int j = 0;
    int restart = 0; // 계산을 끝내고 다시 시작할때(연산자)
    int hit = 0; //버튼 클릭시 카운트 hit 알림 변수
    int input = 0; //입력의 유무 입력이 되었으면 while문 끝에 리셋
    int x = 1;
    int size = 0; //라인당 피/연산자 개수 카운터
    int new = 0; // = 연산 해준뒤, 새로운 입력값 받을때, 초기화 해주기 위해 설정해놓은 변수
    int err = 0; // invalid operation 여부

    wiringPiSetup();
    initialize_textlcd();
    pinMode(BTN1, INPUT);   pullUpDnControl(BTN1, PUD_UP);
    pinMode(BTN2, INPUT);   pullUpDnControl(BTN2, PUD_UP);
    pinMode(BTN3, INPUT);   pullUpDnControl(BTN3, PUD_UP);
    pinMode(BTN4, INPUT);   pullUpDnControl(BTN4, PUD_UP);
    pinMode(BTN5, INPUT);   pullUpDnControl(BTN5, PUD_UP);
    pinMode(BTN6, INPUT);   pullUpDnControl(BTN6, PUD_UP);
    pinMode(BTN7, INPUT);   pullUpDnControl(BTN7, PUD_UP);
    pinMode(BTN8, INPUT);   pullUpDnControl(BTN8, PUD_UP);
    pinMode(BTN9, INPUT);   pullUpDnControl(BTN9, PUD_UP);
    pinMode(BTN0, INPUT);   pullUpDnControl(BTN0, PUD_UP);
    pinMode(BTNEQL, INPUT);   pullUpDnControl(BTNEQL, PUD_UP);
    pinMode(BTNPLS, INPUT);   pullUpDnControl(BTNPLS, PUD_UP);
    pinMode(BTNMIN, INPUT);   pullUpDnControl(BTNMIN, PUD_UP);

    while (1) {
        x = 1;
        if (size > 15 && hit <= 32) {  //오버플로우가 아니라면 줄바꿈
            putCmd4(0xC0); size = 0;
        }

        if (hit > 32)  //오버플로우시 lcd표시
        {
            initialize_textlcd();
            for (i = 0; i < ovrf_len; i++)
            {
                putChar(ovrf[i]);
            }
            delay(2000);
            initialize_textlcd();
            memset(buf, '0', sizeof(buf));
            size = 0;
            hit = 0;

        }

        if (err == 1) //invalid check
        {
            initialize_textlcd();
            for (i = 0; i < invalid_len; i++)putChar(invalid[i]);
            putCmd4(0xC0);
            for (i = 0; i < oper_len; i++)putChar(oper[i]);
            delay(2000);
            initialize_textlcd();
            memset(buf, '0', sizeof(buf));
            size = 0;
            hit = 0;
            new = 0;
            restart = 0;
            err = 0;

        }

      


        for (i = 0; i < 13; i++) {

            if ((x &= digitalRead(a[i])) == LOW && !input && i < 10) {
                if (new == 1 && restart == 1) {
                    initialize_textlcd();
                    memset(buf, '0', sizeof(buf));
                    new = 0;
                    restart = 0;
                    size = 0;
                    hit = 0;
                }
                putChar(i + '0');
                size++;
                buf[len++] = i + '0';
                input = 1;
                hit++;
            }




            else if ((x &= digitalRead(a[i])) == LOW && !input && i == 10) {
                if (buf[len - 1] == '-' || buf[len - 1] == '+')
                {
                    err = 1;
                    break;
                }
                putChar('=');
                input = 1;
                size++;
                hit++;
                buf[len++] = '=';


                char rs[100];
                int res = calc(buf, len);

                sprintf(rs, "%d", res);
                int p = strlen(rs);
                len = 0;

                memset(buf, '0', sizeof(buf));

                if (hit>15&&(p+size>15)) //=연산시 오버플로우 발생여부 확인
                {
                    
                    initialize_textlcd();
                    for (i = 0; i < ovrf_len; i++)
                    {
                        putChar(ovrf[i]);
                    }
                    delay(2000);
                    initialize_textlcd();
                    memset(buf, '0', sizeof(buf));
                    size = 0;
                    hit = 0;
                    new = 0;
                    restart = 0;
                    
                    break;
                }

                for (j = 0; j < p; j++) {

                    if (size > 15)  //줄바꿈
                    {
                        putCmd4(0xC0);
                        size = 0;
                    }
                    putChar(rs[j]);
                    size++; hit++;
                    buf[len++] = rs[j];
                }


                new = 1;
                restart = 1;
                hit = 0;
            }




            else if ((x &= digitalRead(a[i])) == LOW && !input && i == 11) {
                if (buf[len - 1] == '-' || buf[len - 1] == '+')
                {
                    err = 1;
                    break;
                }
                if (restart == 1) {
                    initialize_textlcd();
                    memset(buf, '0', sizeof(buf));

                    new = 0;
                    restart = 0;
                    size = 0;
                    hit = 0;

                    putChar('+');
                    input = 1;
                    size++; hit++;
                    buf[len++] = '+';
                }
                else {
                    putChar('+');
                    input = 1;
                    size++; hit++;
                    buf[len++] = '+';
                }
            }
            else if ((x &= digitalRead(a[i])) == LOW && !input && i == 12) {
                if (buf[len - 1] == '-' || buf[len - 1] == '+')
                {
                    err = 1;
                    break;
                }

                if (restart == 1) {
                    initialize_textlcd();
                    memset(buf, '0', sizeof(buf));

                    new = 0;
                    restart = 0;
                    size = 0;
                    hit = 0;

                    putChar('-');
                    input = 1;
                    size++; hit++;
                    buf[len++] = '-';
                }
                else {
                    putChar('-');
                    input = 1;
                    size++; hit++;
                    buf[len++] = '-';
                }
            }
            else continue;
        }
        delay(10);
        if (x && input)input = 0;


    }
}